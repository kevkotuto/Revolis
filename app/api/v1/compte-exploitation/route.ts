import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '../../../../lib/prisma';
import { checkPermission, logAction } from '../../../../lib/middleware/permissions';
import { z } from 'zod';

// Schéma de validation pour la génération du compte d'exploitation
const compteExploitationSchema = z.object({
  companyId: z.string({ required_error: 'ID d\'entreprise requis' }),
  anneeN: z.number().int().min(2000).max(2100),
  includeAnneeNPlusUn: z.boolean().default(true),
  includeAnneeNPlusDeux: z.boolean().default(false),
  saveReport: z.boolean().default(true)
});

// GET - Récupérer les comptes d'exploitation existants
export async function GET(request: NextRequest) {
  try {
    // Vérifier les permissions
    const permissionCheck = await checkPermission(request, {
      action: 'READ',
      resource: 'COMPANY'
    });
    
    if (!permissionCheck.allowed) {
      return permissionCheck.response;
    }

    // Extraire les paramètres de requête
    const { searchParams } = new URL(request.url);
    const companyId = searchParams.get('companyId');
    const reportId = searchParams.get('reportId');
    const year = searchParams.get('year');
    
    // Paramètres de pagination
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    const skip = (page - 1) * limit;
    
    // Si un ID de rapport est fourni, récupérer un rapport spécifique
    if (reportId) {
      const compteExploitation = await prisma.compteExploitation.findUnique({
        where: { id: reportId }
      });
      
      if (!compteExploitation) {
        return NextResponse.json(
          { error: 'Compte d\'exploitation non trouvé' },
          { status: 404 }
        );
      }
      
      // Vérifier les permissions basées sur l'entreprise
      if (permissionCheck.role !== 'SUPER_ADMIN' && 
          permissionCheck.user?.companyId !== compteExploitation.companyId) {
        return NextResponse.json(
          { error: "Vous n'avez pas les permissions nécessaires pour consulter ce compte d'exploitation" },
          { status: 403 }
        );
      }
      
      // Journaliser l'action
      await logAction(
        permissionCheck.user!.id,
        'READ',
        'COMPANY',
        reportId,
        { action: "Consultation d'un compte d'exploitation" }
      );
      
      return NextResponse.json(compteExploitation);
    }
    
    // Construire la clause where pour le filtrage
    const where: any = {};
    
    // Filtrer par entreprise
    if (companyId) {
      where.companyId = companyId;
    } else if (permissionCheck.role === 'COMPANY_ADMIN' && permissionCheck.user?.companyId) {
      // Les admins d'entreprise ne voient que les comptes de leur entreprise
      where.companyId = permissionCheck.user.companyId;
    }
    
    // Filtrer par année
    if (year) {
      where.anneeN = parseInt(year);
    }
    
    // Récupérer le nombre total pour la pagination
    const total = await prisma.compteExploitation.count({ where });
    
    // Récupérer les comptes d'exploitation
    const comptesExploitation = await prisma.compteExploitation.findMany({
      where,
      skip,
      take: limit,
      orderBy: {
        createdAt: 'desc'
      },
      include: {
        company: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    
    // Journaliser l'action
    await logAction(
      permissionCheck.user!.id,
      'READ',
      'COMPANY',
      'multiple',
      { action: "Consultation des comptes d'exploitation" }
    );
    
    return NextResponse.json({
      items: comptesExploitation,
      pagination: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Erreur lors de la récupération des comptes d\'exploitation:', error);
    return NextResponse.json(
      { error: 'Erreur serveur lors de la récupération des comptes d\'exploitation' },
      { status: 500 }
    );
  }
}

// POST - Générer un compte d'exploitation
export async function POST(request: NextRequest) {
  try {
    // Vérifier les permissions
    const permissionCheck = await checkPermission(request, {
      action: 'CREATE',
      resource: 'COMPANY'
    });
    
    if (!permissionCheck.allowed) {
      return permissionCheck.response;
    }
    
    // Vérifier que l'utilisateur est un administrateur
    if (permissionCheck.role !== 'SUPER_ADMIN' && permissionCheck.role !== 'COMPANY_ADMIN') {
      return NextResponse.json(
        { error: "Vous n'avez pas les permissions nécessaires pour générer un compte d'exploitation" },
        { status: 403 }
      );
    }

    // Extraire et valider les données
    const data = await request.json();
    const validationResult = compteExploitationSchema.safeParse(data);
    
    if (!validationResult.success) {
      return NextResponse.json(
        { error: "Données invalides", details: validationResult.error.format() },
        { status: 400 }
      );
    }
    
    const { 
      companyId, 
      anneeN, 
      includeAnneeNPlusUn, 
      includeAnneeNPlusDeux,
      saveReport 
    } = validationResult.data;
    
    // Vérifier que l'entreprise existe
    const company = await prisma.company.findUnique({
      where: { id: companyId }
    });
    
    if (!company) {
      return NextResponse.json(
        { error: "Entreprise non trouvée" },
        { status: 404 }
      );
    }
    
    // Vérifier que l'utilisateur a le droit de générer un compte pour cette entreprise
    if (permissionCheck.role === 'COMPANY_ADMIN' && 
        permissionCheck.user?.companyId !== companyId) {
      return NextResponse.json(
        { error: "Vous ne pouvez pas générer de compte d'exploitation pour une autre entreprise" },
        { status: 403 }
      );
    }
    
    // Générer les données du compte d'exploitation
    const compteData = await genererCompteExploitation(
      companyId, 
      anneeN, 
      includeAnneeNPlusUn, 
      includeAnneeNPlusDeux
    );
    
    // Si sauvegarde demandée, enregistrer le compte d'exploitation
    let savedCompte = null;
    if (saveReport) {
      savedCompte = await prisma.compteExploitation.create({
        data: {
          companyId,
          anneeN,
          title: `Compte d'exploitation ${anneeN}${includeAnneeNPlusUn ? ` - ${anneeN + 1}` : ''}${includeAnneeNPlusDeux ? ` - ${anneeN + 2}` : ''}`,
          createdById: permissionCheck.user!.id,
          data: compteData
        }
      });
      
      // Journaliser l'action
      await logAction(
        permissionCheck.user!.id,
        'CREATE',
        'COMPANY',
        savedCompte.id,
        { 
          action: "Création d'un compte d'exploitation",
          companyId,
          anneeN
        }
      );
    }
    
    return NextResponse.json({
      compte: compteData,
      savedReport: savedCompte,
      message: saveReport ? "Compte d'exploitation généré et sauvegardé" : "Compte d'exploitation généré"
    }, { status: 201 });
  } catch (error) {
    console.error('Erreur lors de la génération du compte d\'exploitation:', error);
    return NextResponse.json(
      { error: 'Erreur serveur lors de la génération du compte d\'exploitation' },
      { status: 500 }
    );
  }
}

// Fonction pour générer les données du compte d'exploitation
async function genererCompteExploitation(
  companyId: string, 
  anneeN: number, 
  includeAnneeNPlusUn: boolean, 
  includeAnneeNPlusDeux: boolean
) {
  // Définir les périodes pour les données
  const debutAnneeN = new Date(anneeN, 0, 1); // 1er janvier année N
  const finAnneeN = new Date(anneeN, 11, 31); // 31 décembre année N
  
  const debutAnneeNPlus1 = includeAnneeNPlusUn ? new Date(anneeN + 1, 0, 1) : null;
  const finAnneeNPlus1 = includeAnneeNPlusUn ? new Date(anneeN + 1, 11, 31) : null;
  
  const debutAnneeNPlus2 = includeAnneeNPlusDeux ? new Date(anneeN + 2, 0, 1) : null;
  const finAnneeNPlus2 = includeAnneeNPlusDeux ? new Date(anneeN + 2, 11, 31) : null;
  
  // Récupérer les données financières pour l'année N
  const donneesAnneeN = await recupererDonneesFinancieres(companyId, debutAnneeN, finAnneeN);
  
  // Récupérer les données pour les années suivantes si demandé
  const donneesAnneeNPlus1 = includeAnneeNPlusUn && debutAnneeNPlus1 && finAnneeNPlus1 
    ? await recupererDonneesFinancieres(companyId, debutAnneeNPlus1, finAnneeNPlus1)
    : null;
  
  const donneesAnneeNPlus2 = includeAnneeNPlusDeux && debutAnneeNPlus2 && finAnneeNPlus2
    ? await recupererDonneesFinancieres(companyId, debutAnneeNPlus2, finAnneeNPlus2)
    : null;
  
  // Structurer les données selon le format standard du compte d'exploitation
  return {
    meta: {
      companyId,
      anneeN,
      includeAnneeNPlusUn,
      includeAnneeNPlusDeux,
      dateGeneration: new Date()
    },
    headers: [
      "DÉSIGNATION",
      "CALCUL",
      `ANNÉE ${anneeN}`,
      includeAnneeNPlusUn ? `ANNÉE ${anneeN + 1}` : null,
      includeAnneeNPlusDeux ? `ANNÉE ${anneeN + 2}` : null
    ].filter(Boolean),
    produitsExploitation: {
      titre: "Produits d'exploitation",
      details: [
        {
          designation: "Ventes de marchandises",
          code: "A",
          valeurs: [
            donneesAnneeN.ventesMarchandises,
            donneesAnneeNPlus1?.ventesMarchandises || null,
            donneesAnneeNPlus2?.ventesMarchandises || null
          ]
        },
        {
          designation: "Production vendue (Biens)",
          code: "B",
          valeurs: [
            donneesAnneeN.productionVendueBiens,
            donneesAnneeNPlus1?.productionVendueBiens || null,
            donneesAnneeNPlus2?.productionVendueBiens || null
          ]
        },
        {
          designation: "Prestations vendues",
          code: "C",
          valeurs: [
            donneesAnneeN.prestationsVendues,
            donneesAnneeNPlus1?.prestationsVendues || null,
            donneesAnneeNPlus2?.prestationsVendues || null
          ]
        },
        {
          designation: "Chiffre d'affaires",
          code: "D = A+B+C",
          valeurs: [
            donneesAnneeN.chiffreAffaires,
            donneesAnneeNPlus1?.chiffreAffaires || null,
            donneesAnneeNPlus2?.chiffreAffaires || null
          ]
        },
        {
          designation: "Production stockée",
          code: "E",
          valeurs: [
            donneesAnneeN.productionStockee,
            donneesAnneeNPlus1?.productionStockee || null,
            donneesAnneeNPlus2?.productionStockee || null
          ]
        },
        {
          designation: "Production immobilisée",
          code: "F",
          valeurs: [
            donneesAnneeN.productionImmobilisee,
            donneesAnneeNPlus1?.productionImmobilisee || null,
            donneesAnneeNPlus2?.productionImmobilisee || null
          ]
        },
        {
          designation: "Subvention d'exploitation",
          code: "G",
          valeurs: [
            donneesAnneeN.subventionExploitation,
            donneesAnneeNPlus1?.subventionExploitation || null,
            donneesAnneeNPlus2?.subventionExploitation || null
          ]
        },
        {
          designation: "Reprises sur provisions et amortissements, transfert de charges",
          code: "H",
          valeurs: [
            donneesAnneeN.reprisesProvisions,
            donneesAnneeNPlus1?.reprisesProvisions || null,
            donneesAnneeNPlus2?.reprisesProvisions || null
          ]
        },
        {
          designation: "Autres produits",
          code: "I",
          valeurs: [
            donneesAnneeN.autresProduits,
            donneesAnneeNPlus1?.autresProduits || null,
            donneesAnneeNPlus2?.autresProduits || null
          ]
        },
        {
          designation: "Total des produits d'exploitation",
          code: "J= E+ F+G+H +I",
          valeurs: [
            donneesAnneeN.totalProduitsExploitation,
            donneesAnneeNPlus1?.totalProduitsExploitation || null,
            donneesAnneeNPlus2?.totalProduitsExploitation || null
          ]
        }
      ]
    },
    chargesExploitation: {
      titre: "Charges d'exploitation",
      details: [
        {
          designation: "Achat de marchandises",
          code: "K",
          valeurs: [
            donneesAnneeN.achatMarchandises,
            donneesAnneeNPlus1?.achatMarchandises || null,
            donneesAnneeNPlus2?.achatMarchandises || null
          ]
        },
        {
          designation: "Variation de stock",
          code: "L",
          valeurs: [
            donneesAnneeN.variationStockMarchandises,
            donneesAnneeNPlus1?.variationStockMarchandises || null,
            donneesAnneeNPlus2?.variationStockMarchandises || null
          ]
        },
        {
          designation: "Achat de matières et autres approvisionnements",
          code: "M",
          valeurs: [
            donneesAnneeN.achatMatieres,
            donneesAnneeNPlus1?.achatMatieres || null,
            donneesAnneeNPlus2?.achatMatieres || null
          ]
        },
        {
          designation: "Variation de stock",
          code: "N",
          valeurs: [
            donneesAnneeN.variationStockMatieres,
            donneesAnneeNPlus1?.variationStockMatieres || null,
            donneesAnneeNPlus2?.variationStockMatieres || null
          ]
        },
        {
          designation: "Autres achats et charges externes",
          code: "O",
          valeurs: [
            donneesAnneeN.autresAchatsCharges,
            donneesAnneeNPlus1?.autresAchatsCharges || null,
            donneesAnneeNPlus2?.autresAchatsCharges || null
          ]
        },
        {
          designation: "Impôts, taxes et versements assimilés",
          code: "P",
          valeurs: [
            donneesAnneeN.impotsTaxes,
            donneesAnneeNPlus1?.impotsTaxes || null,
            donneesAnneeNPlus2?.impotsTaxes || null
          ]
        },
        {
          designation: "Salaires et traitements",
          code: "Q",
          valeurs: [
            donneesAnneeN.salairesTraitements,
            donneesAnneeNPlus1?.salairesTraitements || null,
            donneesAnneeNPlus2?.salairesTraitements || null
          ]
        },
        {
          designation: "Charges sociales du personnel",
          code: "R",
          valeurs: [
            donneesAnneeN.chargesSociales,
            donneesAnneeNPlus1?.chargesSociales || null,
            donneesAnneeNPlus2?.chargesSociales || null
          ]
        },
        {
          designation: "Dotations aux amortissement",
          code: "S",
          valeurs: [
            donneesAnneeN.dotationsAmortissement,
            donneesAnneeNPlus1?.dotationsAmortissement || null,
            donneesAnneeNPlus2?.dotationsAmortissement || null
          ]
        },
        {
          designation: "Dotations aux provisions",
          code: "T",
          valeurs: [
            donneesAnneeN.dotationsProvisions,
            donneesAnneeNPlus1?.dotationsProvisions || null,
            donneesAnneeNPlus2?.dotationsProvisions || null
          ]
        },
        {
          designation: "Autres charges",
          code: "U",
          valeurs: [
            donneesAnneeN.autresCharges,
            donneesAnneeNPlus1?.autresCharges || null,
            donneesAnneeNPlus2?.autresCharges || null
          ]
        },
        {
          designation: "Total des charges d'exploitation",
          code: "V = K+L+M+N+O+P+Q+R+S+T+U",
          valeurs: [
            donneesAnneeN.totalChargesExploitation,
            donneesAnneeNPlus1?.totalChargesExploitation || null,
            donneesAnneeNPlus2?.totalChargesExploitation || null
          ]
        }
      ]
    },
    resultatExploitation: {
      designation: "Résultats d'exploitation",
      code: "W = J - V",
      valeurs: [
        donneesAnneeN.resultatExploitation,
        donneesAnneeNPlus1?.resultatExploitation || null,
        donneesAnneeNPlus2?.resultatExploitation || null
      ]
    }
  };
}

// Fonction pour récupérer les données financières sur une période
async function recupererDonneesFinancieres(companyId: string, dateDebut: Date, dateFin: Date) {
  // Ventes de marchandises (factures avec produits de type 'MARCHANDISE')
  const ventesMarchandises = await prisma.invoice.aggregate({
    _sum: {
      total: true
    },
    where: {
      companyId,
      issueDate: {
        gte: dateDebut,
        lte: dateFin
      },
      items: {
        some: {
          type: 'MARCHANDISE'
        }
      },
      status: { not: 'CANCELLED' }
    }
  });

  // Production vendue (Biens) - factures avec produits de type 'BIEN'
  const productionVendueBiens = await prisma.invoice.aggregate({
    _sum: {
      total: true
    },
    where: {
      companyId,
      issueDate: {
        gte: dateDebut,
        lte: dateFin
      },
      items: {
        some: {
          type: 'BIEN'
        }
      },
      status: { not: 'CANCELLED' }
    }
  });

  // Prestations vendues - factures avec produits de type 'SERVICE'
  const prestationsVendues = await prisma.invoice.aggregate({
    _sum: {
      total: true
    },
    where: {
      companyId,
      issueDate: {
        gte: dateDebut,
        lte: dateFin
      },
      items: {
        some: {
          type: 'SERVICE'
        }
      },
      status: { not: 'CANCELLED' }
    }
  });

  // Chiffre d'affaires - toutes les factures
  const chiffreAffaires = await prisma.invoice.aggregate({
    _sum: {
      total: true
    },
    where: {
      companyId,
      issueDate: {
        gte: dateDebut,
        lte: dateFin
      },
      status: { not: 'CANCELLED' }
    }
  });

  // Autres éléments (simplifiés pour l'exemple)
  // Dans une implémentation réelle, vous récupéreriez ces données de différentes tables

  // Calculer les achats de marchandises (supposons que ce sont les paiements aux fournisseurs)
  const achatMarchandises = await prisma.expense.aggregate({
    _sum: {
      amount: true
    },
    where: {
      companyId,
      date: {
        gte: dateDebut,
        lte: dateFin
      },
      category: {
        name: { contains: 'Achat', mode: 'insensitive' }
      }
    }
  });

  // Salaires et charges sociales
  const salairesEtCharges = await prisma.expense.aggregate({
    _sum: {
      amount: true
    },
    where: {
      companyId,
      date: {
        gte: dateDebut,
        lte: dateFin
      },
      category: {
        name: { contains: 'Salaire', mode: 'insensitive' }
      }
    }
  });

  // Charges sociales (estimé à 45% des salaires pour simplifier)
  const salairesMontant = salairesEtCharges._sum.amount?.toNumber() || 0;
  const chargesSocialesMontant = salairesMontant * 0.45;

  // Impôts et taxes
  const impotsTaxes = await prisma.expense.aggregate({
    _sum: {
      amount: true
    },
    where: {
      companyId,
      date: {
        gte: dateDebut,
        lte: dateFin
      },
      category: {
        name: { contains: 'Impôt', mode: 'insensitive' }
      }
    }
  });

  // Autres charges d'exploitation
  const autresCharges = await prisma.expense.aggregate({
    _sum: {
      amount: true
    },
    where: {
      companyId,
      date: {
        gte: dateDebut,
        lte: dateFin
      },
      category: {
        name: { notIn: ['Achat', 'Salaire', 'Impôt'] }
      }
    }
  });

  // Valeurs pour les postes pour lesquels nous n'avons pas de données précises
  // Dans une implémentation réelle, ces valeurs proviendraient de tables appropriées
  const productionStockee = 0;
  const productionImmobilisee = 0;
  const subventionExploitation = 0;
  const reprisesProvisions = 0;
  const autresProduits = 0;
  const variationStockMarchandises = 0;
  const achatMatieres = 0;
  const variationStockMatieres = 0;
  const dotationsAmortissement = 0;
  const dotationsProvisions = 0;

  // Calcul des totaux
  const ventesMarchandisesMontant = ventesMarchandises._sum.total?.toNumber() || 0;
  const productionVendueBiensMontant = productionVendueBiens._sum.total?.toNumber() || 0;
  const prestationsVenduesMontant = prestationsVendues._sum.total?.toNumber() || 0;
  const chiffreAffairesMontant = chiffreAffaires._sum.total?.toNumber() || 0;
  
  const totalProduitsExploitation = chiffreAffairesMontant + 
    productionStockee + productionImmobilisee + subventionExploitation + 
    reprisesProvisions + autresProduits;

  const achatMarchandisesMontant = achatMarchandises._sum.amount?.toNumber() || 0;
  const impotsTaxesMontant = impotsTaxes._sum.amount?.toNumber() || 0;
  const autresChargesMontant = autresCharges._sum.amount?.toNumber() || 0;
  const autresAchatsChargesMontant = autresChargesMontant * 0.7; // Simplification
  
  const totalChargesExploitation = achatMarchandisesMontant + 
    variationStockMarchandises + achatMatieres + variationStockMatieres + 
    autresAchatsChargesMontant + impotsTaxesMontant + salairesMontant + 
    chargesSocialesMontant + dotationsAmortissement + dotationsProvisions + 
    (autresChargesMontant * 0.3); // Reste des autres charges

  const resultatExploitation = totalProduitsExploitation - totalChargesExploitation;

  // Retourner les données structurées
  return {
    ventesMarchandises: ventesMarchandisesMontant,
    productionVendueBiens: productionVendueBiensMontant,
    prestationsVendues: prestationsVenduesMontant,
    chiffreAffaires: chiffreAffairesMontant,
    productionStockee,
    productionImmobilisee,
    subventionExploitation,
    reprisesProvisions,
    autresProduits,
    totalProduitsExploitation,

    achatMarchandises: achatMarchandisesMontant,
    variationStockMarchandises,
    achatMatieres,
    variationStockMatieres,
    autresAchatsCharges: autresAchatsChargesMontant,
    impotsTaxes: impotsTaxesMontant,
    salairesTraitements: salairesMontant,
    chargesSociales: chargesSocialesMontant,
    dotationsAmortissement,
    dotationsProvisions,
    autresCharges: autresChargesMontant * 0.3,
    totalChargesExploitation,

    resultatExploitation
  };
} 